import * as cdk from 'aws-cdk-lib';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as elbv2 from 'aws-cdk-lib/aws-elasticloadbalancingv2';
import * as elbv2_targets from 'aws-cdk-lib/aws-elasticloadbalancingv2-targets';
import { Construct } from 'constructs';

// Define an interface for the properties passed to the stack (such as the region and account)
interface MultiRegionStackProps extends cdk.StackProps {
  region: string;  // Region property
  account: string; // Account property
}

export class MultiRegionStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props: MultiRegionStackProps) {
    super(scope, id, props);

    const region = props.region;  // Capture the region from props

// ------------------------------------ List

// Security Group
    const securityGroup = new ec2.SecurityGroup(this, 'AllowHttpHttpsTrafficSG', {
      vpc,
      description: 'Security group for allowing HTTP and HTTPS traffic only',
      securityGroupName: 'PublicSubnet_SG_Port_80_443'  // Set the name here
    });

    // Allow inbound traffic
    securityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),          // Allows any IPv4 address
      ec2.Port.tcp(80),            // Port 80 (HTTP)
      'Allow inbound HTTP traffic'
    );

    securityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),          // Allows any IPv4 address
      ec2.Port.tcp(443),           // Port 443 (HTTPS)
      'Allow inbound HTTPS traffic'
    );

// ------------------------------------ Private

// Define configurations for Private Subnets
    const PrivateSubnetConfigs = [
      { availabilityZone: 'eu-central-1a', cidrBlock: '10.0.2.0/24' },
      { availabilityZone: 'eu-central-1b', cidrBlock: '10.0.5.0/24' },
    ];

// NAT Gateways
    const natGateways: ec2.CfnNatGateway[] = [];
    publicSubnets.forEach((publicSubnet, index) => {
      const natGatewayEip = new ec2.CfnEIP(this, `NatGatewayEIP_${index + 1}`);

      const natGateway = new ec2.CfnNatGateway(this, `NatGateway_${index + 1}`, {
        subnetId: publicSubnet.ref,
        allocationId: natGatewayEip.attrAllocationId,
        tags: [
          {
            key: 'Name',
            value: `PublicNatGateway_${index + 1}`,
          },
        ],
      });

      natGateways.push(natGateway);
    });

// Private Subnets
    const privateSubnets: ec2.CfnSubnet[] = PrivateSubnetConfigs.map((config, index) => {
    // Private Subnet
      const privateSubnet = new ec2.CfnSubnet(this, `PrivateSubnet_${index + 1}`, {
        vpcId: vpc.vpcId,
        cidrBlock: config.cidrBlock,
        availabilityZone: config.availabilityZone,
        tags: [
          {
            key: 'Name',
            value: `PrivateSubnet_${index + 1}`,
          },
        ],
      });

    // Route Table
      const privateRouteTable = new ec2.CfnRouteTable(this, `PrivateRouteTable_${index + 1}`, {
        vpcId: vpc.vpcId,
        tags: [
          {
            key: 'Name',
            value: `PrivateRouteTable_${index + 1}_ToNAT`,
          },
        ],
      });

    // Route to NAT Gateway
      new ec2.CfnRoute(this, `PrivateSubnetRouteTarget_${index + 1}`, {
        routeTableId: privateRouteTable.ref,
        destinationCidrBlock: '0.0.0.0/0',                         // Route all outbound traffic
        natGatewayId: natGateways[index % natGateways.length].ref, // Use NAT Gateway in round-robin
      });

    // Associate the Route Table with the Private Subnet
      new ec2.CfnSubnetRouteTableAssociation(this, `PrivateSubnetRouteTableAssoc_${index + 1}`, {
        subnetId: privateSubnet.ref,
        routeTableId: privateRouteTable.ref,
      });

      return privateSubnet; // Add the subnet to the array
    });

// ------------------------------------ Instances

// Use an existing security group
    const securityGroup_1_all = ec2.SecurityGroup.fromSecurityGroupId(this, 'SecurityGroup', 'sg-0822a6793c27228e3');

// Define the existing IAM role for SSM
    const instanceRole_1 = iam.Role.fromRoleArn(this, 'InstanceRole', 'arn:aws:iam::038462748247:role/SSM-Access-Role');

// Instances
    // Define the AMI as Amazon Linux 2023
    const ami = new ec2.AmazonLinuxImage({
      generation: ec2.AmazonLinuxGeneration.AMAZON_LINUX_2023,
    });

    // Define Startup Script
    const userData = ec2.UserData.forLinux();
    userData.addCommands(
      'sudo yum update -y',
      'sudo yum install docker -y',
      'sudo service docker start',
      'sudo docker pull alexstue/jul24-petclinic:3.0',
      'sudo docker run -d -p 80:8080 alexstue/jul24-petclinic:3.0'
    );

    const instances: ec2.Instance[] = [];
    privateSubnets.forEach((privateSubnet, index) => {
    // Convert CfnSubnet to ISubnet
      const iSubnet = ec2.Subnet.fromSubnetAttributes(this, `ISubnet_${index + 1}`, {
        subnetId: privateSubnet.ref,
        availabilityZone: PrivateSubnetConfigs[index].availabilityZone,
      });

    // Create an instance in the private subnet
      const instance = new ec2.Instance(this, `Instance_${index + 1}`, {
        vpc,
        instanceType: ec2.InstanceType.of(ec2.InstanceClass.T2, ec2.InstanceSize.MICRO),
        machineImage: ami,
        keyName: 'key-aws-1',         // SSH key
        vpcSubnets: {
          subnets: [iSubnet],         // Place the instance in this specific private subnet
        },
        securityGroup: securityGroup_1_all,
        role: instanceRole_1,
      });

    // Add Startup Script
    instance.addUserData(userData.render());

    // Add a Name tag to each instance
      cdk.Tags.of(instance).add('Name', `PrivateInstance_${index + 1}`);

    // Save instance in the array for later use
      instances.push(instance);
    });

// ------------------------------------ Loadbalancer

// Security Group
    const albSecurityGroup = new ec2.SecurityGroup(this, 'InternalALBSecurityGroup', {
      vpc,
      allowAllOutbound: true,
      description: 'Allow internal HTTP traffic to ALB',
    });

    // Allow inbound HTTP Port 80
    albSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),         // Allow traffic from anywhere
      ec2.Port.tcp(80),            // Port 80 for HTTP
      'Allow HTTP traffic from the internet'
    );

// Application Load Balancer
    // Convert the CfnSubnet[] to ISubnet[] using fromSubnetId
    const publicSubnetsAsISubnet: ec2.ISubnet[] = publicSubnets.map((subnet) =>
      ec2.Subnet.fromSubnetId(this, `PublicSubnetRef_${subnet.ref}`, subnet.ref)
    );

    // ALB
    const alb = new elbv2.ApplicationLoadBalancer(this, 'MyALB', {
      vpc,
      internetFacing: true,       // ALB is publicly accessible
      loadBalancerName: 'MyALB',  // Name of the ALB
      securityGroup: albSecurityGroup,  // Attach the ALB security group
      vpcSubnets: {
        subnets: publicSubnetsAsISubnet,  // Use ISubnet[] instead of CfnSubnet[]
      },
    });

// Target Group for all Instances
    const targetGroup = new elbv2.ApplicationTargetGroup(this, 'MyTargetGroup', {
      vpc,
      port: 80,                                  // Target port for instances
      protocol: elbv2.ApplicationProtocol.HTTP,  // Use HTTP protocol
      targetType: elbv2.TargetType.INSTANCE,     // Target type is EC2 instances
      healthCheck: {
        path: '/',                               // Health check path
        interval: cdk.Duration.seconds(30),
      },
    });

// Register each EC2 instance in the private subnets as a target
    instances.forEach((instance, index) => {
      targetGroup.addTarget(new elbv2_targets.InstanceIdTarget(instance.instanceId, 80)); // With Port 80
    });

// Add a listener on port 80 for the internal ALB
    const listener = alb.addListener('InternalListener', {
      port: 80,                            // Listening on port 80 for HTTP traffic
      defaultTargetGroups: [targetGroup],  // Route traffic to the target group
    });



  }
}

*/